메모리와 디스크의 핵심 : 순차논리 - 컴퓨터는 비트를 어떻게 기억하는가
========
- 조합논리 : 입력에 따라 출력이 결정(입력의 현재 상태만을 고려)
- 순차논리 : 입력의 현재 상태와 과거 상태를 함께 고려
# 시간 표현과 상태 기역
> ## 발진자
> - 입력과 출력이 진동하는 되먹임(feedback) 현상 
> ex_크리스털을 활용한 피에조 전기 현상
> ## 클록
> - 발진자 -> 컴퓨터에 클록(신호를 셀 수 있게 해주는 신호)을 제공
> - 비닝 -> 부품을 특성 및 성능에 따라 각기 다른 분류에 분류(편차가 적도록) 
> - 오버클로킹 -> 빈의 중간 정도에 취이하는 부품을 고장이 나지 않을 범위 안에서 클록을 > 빠르게 공급 하는 행위
> ## 래치
> - S-R 래치(set-reset) : 액티브 로우 입력을 받고 보수 출력을 제공 => 출력의 한쪽은 엑티브 하이, 다른 쪽은 엑티브 로우
> ## 게이트가 있는 레치
> ## 플립플롭
> - 에지 : 논리 수준이 한 수준에서 다른 수준으로 전이 되는 중간
> - 플립플롭 : 에지에 의해 데이터 변화가 촉발되는 래치 
> ## 카운터
> - 플립플롭의 응용
> - 발진자에서 나오는 시간을 세고, 그 값을 디코더에 공급해서 숫자를 표시하는 디스플레이어를 제어 
> - ex_ 리플 카운터(빋홍기 카운) => 전파지연으로 인한 출력 오류 문제
> ## 레지스터
> - 클록을 공유하는 D 플립플롭을 한 패키지에 넣은 것
> - 가산기 출려을 사용해 레지스터에 넣고 나면, 가산기 입력을 바꿔도 결과는 바뀌지 않는다.
# 메모리 조직과 주소 지정
> - 주소 => 메모리 => 데이터의 구조
> - 주소 : 행주소 + 열주소 
> - 메모리칩 크기 : 깊이 X 너비 => 행의 수 x 열의 수
> ## 임의 접근 메모리(Random Acess Memory)
> - Static Ram => 비트마다 6개의 트랜지스터가 들어가 동작
> - Dynamic Ram => 커패시터를 활용 + 집적도가 높기 때문에 큰 메모리 칩에서 사용
> ## 읽기 전용 메모(Read only memory)
> - writing 이후 여러번 read 할 수 있는 메모리
> - ex_IBM카드리더, 천공 종이 테이프, 코어 로프 메모리, PROM, EPROM, EEPROM 등
# 블록 장치
> - 디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다
> - 블록은 역사적으로 섹터라고 불러왔고 디스크에서 읽고 쓰기가 가능한 가장 작은 단위이다. ex_ 한 바이트 수정 시 전체 블록을 읽고 원하는 바이트를 바꾼 후 전체 블록을 다시 스는 방식으로 작동
# 플래시 메모리와 SSD
> - 플래시 메모리 : EEPROM 유형의 매체 => 버킷에 전자를 담는 방식으로 작동. 읽을 때는 임의 접근 장치, 쓸 때는 블록 접근 장치의 방식으로 작동
> - SSD(solid-state drive) 
# 오류 감지와 정정
> -  1) 원본데이터를 복사하여 데이터 오류를 확인 하는 방식
> -  2) parity 활용 : 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수의 홀짝 여부를 나타내는 1비트를 데이터에 덧붙이는 방식. 
> -  짝수 패리티는 모든 비트를 서로 XOR 한 값을 사용하며, 홀수 패리티는 그 보수를 활용함.
> -  오류가 짝수번 발생하면 오류를 알아낼 수 없음
> -  3) 해밍코드를 내장한 오류 검사와 정정 메모리 칩 활용
> -  4) 체크섬, 순환 중복 검사 등
# 하드웨어와 스프트웨어 비교
>  
