# 언어란 무엇인가
모든 언어의 뜻은 기호의 집합으로 인코딩된다.
언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.

# 문자 언어
문자 언어의 틀은 세가지 요소로 구성된다. 기호가 들어갈 상자, 상자에 들어갈 기호, 상자의 순서.

# 비트
- 비트라는 단어는 binary(이진법)과 digit(숫자)가 합쳐진 말이다.
- **바이너리** => 두가지 부분으로 이뤄진 어떤 대상을 의미,  <br/> **디지트 ** => 10진수를 표현하는 10가지 기호를 의미

# 논리 연산
- 예 / 아니요 질문에 대한 답을 표현하는 것. 
- 다른 비트들이 표현하는 내용을부터 새로운 비트를 만들어내는 동작

> ## 불리언 대수
> - NOT (논리적 반대)
>  : YES => NO / NO => YES
> - AND 
>  : YES & YES || NO & NO => YES /  YES & NO || NO &  YES => NO
> - OR
>  : YES & YES || YES & NO || NO & YES => YES / NO & NO => NO
> - XOR
>  : YES & NO || NO & YES => YES / YES & YES || NO & NO => NO
>
> ## 드모르간 법칙
> - A AND B == NOT(NOT A OR NOT B)
> - ex) 춥다 AND 비가 온다 = NOT NOT 춥다 OR NOT NOT 비가 온다
> - 정논리(긍정적인 논리)와 부논리(부정적인 논리)를 기술하는 명제를 사용할 때 활용 가능.

# 정수를 비트로 표현하는 방법
> ## 양의 정수 표현
> - LSB(가장 작은 유효 비트), MSB(가장 큰 유효 비트), LEADING ZERO(가장 왼쪽에 있는 bit보다 더 왼쪽에 추가된 0)
> ## 2진수 덧셈
> - 비트를 더한 결과 = 두 비트의 XOR, 올림 = 두 비트의 AND 한 값
> - 덧셈 결과가 표현할 수 있는 비트의 개수 범위를 멋어나는 경우 => 오버플로 발생(==MSB에서 올림이 발생했다)
> - 음수의 값이 나오는 경우 => 언더플로 발생(==MSB 위쪽에서 1을 빌려오는 경우)
> ## 음수 표현
> 1) 부호 크기 표현법
> 2) 1의 보수 
> 3) 2의 보수

# 실수를 표현하는 방법
> 1) 고정소수점 표현법
> - 소수점의 위치를 임의로 정해놓고, 정수부분과 분수 부분을 표현
> 2) **부동 소수점 표현법**
> 3) IEEE 부동소수점 수 표준

# 진수를 다루는 쉬운 방법
> 1) 8진 표현법
> 2) **16진 표현법**

# 비트 그룹의 이름
- 4bit = nibble, 8bit = byte, 16bit = half word, 32bit = word, 64bit = double word
- word = 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기(가장 빠르게 처리할 수 있는 가장 큰 덩어리)
- kilobyte(2^10), megabyte(2^20), gigabyte(2^30), terabyte(2^40)
- 밑이 10으로 혼용되기도 함. IEC 표준 접두사에서는 2를 밑으로 하는 경우를 키비, 메비, 기비, 테비 등의 용어로 구분.

# 텍스트 표현
> ## 아스키 코드 (정보 교환을 위한 미국 표준코드, American Standard Code for Information Interchange)
> - 키보드 내 모든 기호에 대해 7비트 수 값을 할당
> - ex) A == 65, B==66 ...
> - 글자 출력이 아닌, 장치를 제어하기 위해 쓰이는 제어문자도 존재
> - ex) NUL == 널, STX == Start of Text ...
> ## 다른 표준의 진화
> - ISO(International Standards Organization)-646, ISO-8859 등
> - **UNICODE** => 최초 16비트, 현재 21비트까지 확장
> ## 유니코드 변환 형식 8비트(UTF-8)
> - 인코딩 : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
> - 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩 (p.82 그림 1-16 참조)

# 문자를 사용한 수 표현
> ## 출력 가능하게 변경한 인코딩(Quoted-Printable encoding) / QP 인코딩
> - 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법
> - 출력가능 == 아스키코드에서 제어문자가 아니라는 뜻과 동일
> - 전자우편 첨부를 처리하기 만들어짐
> - 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 비효율적인 방법
> ## 베이스64 인코딩
> - 3바이트 데이터의 24비트를 4가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현
> - 원본 데이터 길이가 반드시 3바이트의 배수가 아닐 수도 있음 => 패딩 문자를 통한 문제 해결
> - 2바이트가 남으면 끝에 =, 1바이트가 남으면 == 를 붙이는 방식
> ## URL 인코딩 / 퍼센트 인코딩
> - % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩
> - / => 아스키코드(2F), 리터럴로 사용할 경우 %2F. 
> - % => 리터럴로 표현할 경우 %25
