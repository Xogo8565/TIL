아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
===================================================

- 전통적인 생성자 방식 대신 static factory method를 고려
- ex_boolean -> Boolean(Wrapper) 활용한 예시

 ```java
 public static Boolean valueOf(boolean b) {
	 return b ? Boolean.TRUE : Boolean.False
 }
 ```
------------------------------------------------------
# Static Factory Method의 장점과 단점

## 장점

- **이름을 가질 수 있다.**
    - 정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
      <br/>ex_BigInteger vs BigInteger.probablePrime
    - 하나의 시그니처로는 생성자를 하나만 만들 수 있다. 하지만, 이름을 가질 수 있는 정적 팩터리 메서드는 이런 제약이 없다. 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자.

-  **호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**
    - 이 덕분에 immutable class는 불필요한 객체 생성을 피할 수 있다.
    (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어올려 준다.
    - 반복되는 요청에 같은 객체를 반환하는 식으로, 언제 어느 인스턴스를 살아있게 할지를 철저히 통제할 수 있다. 이를 인스턴스 통제(instance-controlled) 클래스 라고 한다. 인스턴스를 통제하면 클래스를 singelton으로 만들수도, 인스턴스화 불가(noninstantiable)로 만들수도 있다. 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수도 있다. ( a == b일 때만 a.equals(b)가 성립)
    - 인스턴스 통제는 Flyweight patten의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.
    
- **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
    - 반환할 객체의 클래스를 자유롭게 선택할 수 있게하는 '엄청난 유연성'을 선물한다.
    ⇒ 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.
    이는 **인터페이스 기반 프레임워크를 만드는 핵심 기술**이기도 하다.
    - 컬렉션 프레임워크는 내부의 클래스를 공개하지 않기 때문에 API 외견을 훨씬 작게 만들 수있었다. API를 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮췄다.
    명시한 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 **구현 클래스를 몰라도 된다**. 
    나아가 정적 팩터리 메서드를 사용하는 클라이언트는 얻은 객체를 인터페이스만으로 다루게 된다.
    
- **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
    - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관 없다. 심지어 다음 릴리스에서는 또 다른 클래스의 객체를 반환해도 된다.
    - 클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고, 알 필요도 없다. 타입의 하위 클래스이기만 하면 되는것이다.
    - 
- **정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
    - 이런 유연함이 **service provider framework를 만드는 근간**이 된다. 대표적으로 JDBC가 있다. rovider는 서비스의 구현체다. 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로 부터 분리해준다.
    - service provider framework는 3개의 핵심 컴포넌트로 이뤄진다.
    1. 구현체의 동작을 정의하는 service interface
    2. 제공자가 구현체를 등록할 때 사용하는 provider registration API
    3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 service access API
    - 클라이언트는 service acces API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환한다. ⇒ '유연한 정적 팩터리'의 실체다.

## 단점

- **상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.**
    - 컬렉션 프레임워크의 유틸리티 구현 클래스들은 **상속을 할 수 없다**는 이야기다.
    - 상속보다 컴포지션을 사용 하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 **장점**으로 받아들일 수도 있다.
- **정적 팩토리 메서드는 프로그래머가 찾기 어렵다.**
    - 생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화 할 방법을 알아내야 한다.

---------------------------------------------------------------------------------------------------------------------------
<aside>
💡 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 장단점을 이해하고 사용하는 것이 좋다. 그래도, 정적 팩터리를 사용하는 게 유리한 경우가 많으니 무작정 public 생성자를 제공하던 습관이 있다면 고치자.

</aside>
